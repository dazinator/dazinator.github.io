<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dotnetnuke,dnnpackager | Darrell Tunnell's Blog]]></title>
  <link href="http://darrelltunnell.net/blog/categories/dotnetnuke-dnnpackager/atom.xml" rel="self"/>
  <link href="http://darrelltunnell.net/"/>
  <updated>2016-03-19T21:59:32+00:00</updated>
  <id>http://darrelltunnell.net/</id>
  <author>
    <name><![CDATA[Darrell Tunnell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dnn Extensions - Sources Packages?]]></title>
    <link href="http://darrelltunnell.net/blog/2016/03/19/dnn-extensions-sources-packages-what-are-they/"/>
    <updated>2016-03-19T00:00:00+00:00</updated>
    <id>http://darrelltunnell.net/blog/2016/03/19/dnn-extensions-sources-packages-what-are-they</id>
    <content type="html"><![CDATA[<h2>Sources Packages</h2>

<p>I have been doing some work on DnnPackager recently, and I&rsquo;ve come accross the concept of &ldquo;Source&rdquo; packages. I have to admit I am not entirely new to these, but I&rsquo;ve never personally used them for my projects in the past.</p>

<p>Source packages are basically identical to the ordinary install zip&rsquo;s for your dnn module / extension, i.e you &ldquo;install&rdquo; them into your Dnn site like any other install package, except that they also include &ldquo;source code&rdquo; files within them, like .cs, .vb files etc.</p>

<h2>Why would you want to include source code in your install zip?</h2>

<p>Well this is where things get a little interesting.</p>

<!-- more -->


<p>The two main reasons I can fathom why you would want to include source code in an install zip are that:</p>

<ol>
<li>Your module uses dynamic compilation, and so unless you include source files with the module installation, then it just won&rsquo;t work.</li>
<li>You want to distribute your source code, so that developer&rsquo;s (who pay for it?) can open it up in VS and own it / make changes (improvements?). Usually you&rsquo;d charge for this option, but it&rsquo;s faesible you are just an extremely generous developer (like me) who gives stuff away for free.</li>
</ol>


<p>Number 1 is a necessity really to cater for modules that use dynamic compilation.</p>

<p>Number 2 is an optional thing about you as a developer (or commercial entity), distributing your solution source code in a format that thrid parties can &ldquo;own&rdquo; it - irrespective of whether you have used dynamic compilation or not.</p>

<p>Note: If you are using Dynamic compilation for your module, then people allready have the ability to make changes to the code by simply going into the website directory after the module has been installed, and modifying the code files. But you already knew that right!! Whether they are legally entitled to do so ofcourse, would be down to the licence agreement.</p>

<p>Number 1 and 2 are different.</p>

<h2>Why are they different?</h2>

<p>Because in the first scenario, you are giving IIS the files it needs to compile and run your code within a Dnn website instance. In the second scenario, you are giving <strong>developers</strong> the files they need, to open up your project / solution and <strong>build</strong>, and compile your code, in a manner that spits out everything needed by scenario 1. In other words, the build and compilation that developers do, produces the output that&rsquo;s needed within the website for the compilation that IIS does.</p>

<h2>Why was that last bit important</h2>

<p>Because files related to the build that developers do - i,e the ones that prodice the output that actually needs to be installed to the dnn site, arguable have no business being installed into a Dnn website. Key files, project files, solution files etc etc - there are all completely unrelated to the working / running of your module within Dnn, and have nothing to do with IIS dynamic compilation or anything. They shouldn&rsquo;t be installed in a website period (imho).</p>

<h2>Dual purpose</h2>

<p>There seems to be a dual purpose for the sources package that doesn&rsquo;t sit right with me.
Using it to install source code into the website to support dynamic compilation seems like what it is meant for imho - it is a Dnn installation zip after all.</p>

<p>Using it to provide a third party with your VS solution / project files so that they can open up the solution in an IDE, build and compile the code is a completely different scenario, and I can&rsquo;t see how that second scenario can work reliably just by including a .csproj in a dnn sources install zip - except for in the most simplisitic and basic of scenarios, which rarely happen in the real world.</p>

<h2>Example of some issues with including Sln / Csproj in a sources zip package.</h2>

<p>Currently, if you use widely available project templates to produce &ldquo;sources&rdquo; packages, they will by default, produce a sources &ldquo;zip&rdquo; file for each of the module projects in your solution, and this will contain source code files copied form your project, as well as the csproj, and sln file. (I think the sln will only get included if it lives within the project directory).</p>

<p>Already we hit an issue, as if you have multiple projects in your solution, and the sln file lives in a parent directory of those projects like this:</p>

<pre><code>
solution/mysln.sln
solution/projectA/projectA.csproj
solution/projectB/projectB.csproj
</code></pre>

<p>(which is fairly normal) then the sln file usually won&rsquo;t be included in the sources packages for any of your particular modules as it doesn&rsquo;t live directly within a project directory.</p>

<p>Secondly, if ProjectA has a project reference to ProjectB, and someone downloads the sources package for your projectA module, and opens up the csproj file that you have included in that sources package - the project is going to have a missing project reference to projectB so it won&rsquo;t compile.</p>

<p>There are yet more problems. If your .csproj files reference assemblies from some lib directory within your checkout directory somewhere, as this lib directory won&rsquo;t be included in the sources package (because it doesn&rsquo;t live within the project dir), anyone opening the project file in VS will see missing assembly references, they will have to manually correct them - otherwise the solution won&rsquo;t compile.</p>

<p>If your project files include some custom build targets that live on your machine, or within your checkout directory somewhere, etc etc - you guessed it the person opening the .csproj file is going to have issues because they won&rsquo;t be included in the same location within the sources package.</p>

<h2>Alternatives?</h2>

<p>If you want to give away your VS solution (or sell the source) to a third party, there are better / easier ways to provide access to it without shoehorning it in to the dnn install zip imho!</p>

<p>The easiest may be to just zip up your entire solution (checkout directory), and allow that to be downloaded from some protected location. This does not have to be in a &ldquo;dnn&rdquo; install package format, just a simple zip file that the person recieving can extract and then open up the VS sln file. You want it to be like they just checked out the solution from source control and are now opening up the VS sln file - just like you do right?</p>

<p>If there are some pre-requisites to being able to open and build the solution, add a readme to the zip that explains what a developer must do before attempting to open the solution. This is usually handy to have in your source control anyway - in case you ever need to checkout and open the solution on a new machine one day that doesn&rsquo;t have your dependencies set up. These should be the same steps that any developer new to the company has to go through (including you) when checking out the code for the first time and wanting to open it.</p>

<h2>How does this all tie in with DnnPackager?</h2>

<p>Well, for the next realease of DnnPacakger, I have added rudimentary support for Sources packages (thanks to <a href="https://github.com/nvisionative">@nvisionative</a> for requesting this feature) - so that it will now produce &ldquo;sources&rdquo; packages alongside the standard install zip. However this is currently for the purposes of supporting modules that need to include source files in their installation process into Dnn, which I suspect will mainly just be ones that use dynamic compilation.</p>

<p>It won&rsquo;t include .csproj files or .sln files because at this point in time, I can&rsquo;t see how including them would lead to a reliable experience for the developer opening these up at the other end.</p>

<p>Disagree? Leave some comments below, I&rsquo;d love to be convinced - or to just hear your views!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DotNetNuke - Streamlining Module Development Workflow]]></title>
    <link href="http://darrelltunnell.net/blog/2015/06/13/dotnetnuke-streamlining-module-development/"/>
    <updated>2015-06-13T00:00:00+01:00</updated>
    <id>http://darrelltunnell.net/blog/2015/06/13/dotnetnuke-streamlining-module-development</id>
    <content type="html"><![CDATA[<h2>Module Debugging - Two Approaches</h2>

<p>When developing DotNetNuke modules people take many different approaches but they boil down to two alternatives in terms of workflow:</p>

<ol>
<li><p>Placing / checking out your source code directly into the \DesktopModules folder of a DotNetNuke website, and having your module dll&rsquo;s output to directly into the DotNetNuke website&rsquo;s \bin folder.</p></li>
<li><p>Checking out and working on your code wherever you like, but having to deploy your module (content and assemblies) to a local DNN website when you are ready to run it.</p></li>
</ol>


<p>Both approaches require that you &ldquo;attach to process&rdquo; from within Visual Studio in order to debug your module.</p>

<!-- more -->


<h3>I hate approach #1</h3>

<p>I have all sorts of issues with approach #1. Yes it’s technically possible, but it’s also nasty in my view (not very clean) - I have elaborated on that elsewhere so won’t do so again here in depth, aside to say that I believe #2 is the &ldquo;cleanest&rdquo; approach and that many forms of debugging use #2 as the approach, not #1. For example, xamarin devs, when they debug an android app, you will see that xamarin actually deploys their project to the device / emulator, and then attaches the debugger to the remote process that&rsquo;s running on the device / emulator. The result is that they click &ldquo;Play&rdquo; in VS, and a shortwhile later they are attached and stepping through their code.. It may not be obvious that a deployment took place - but it did. Lastly. i&rsquo;ll point out that #1 creates a coupling between how you structure your source code, and where it needs to be when it&rsquo;s actually deployed.</p>

<h3>But approach #2 is lacking</h3>

<p>So deciding to take approach #2, having to manually copy / deploy your module content  to the DotNetNuke website each time you want to test your module, is just not an efficient use of your time!</p>

<p>What&rsquo;s needed is some nice visual studio integration so that when you are ready to &ldquo;Run / Debug&rdquo; your module, you click one button and bam! chrome opens up, displaying your module, with the debugger attached so you can step through code.</p>

<h3>Can anything be done?</h3>

<p>I have allready made strides to address the inefficiences of #2 so that it&rsquo;s now a lot more streamlined: <a href="https://github.com/dazinator/DnnPackager">https://github.com/dazinator/DnnPackager</a> - it&rsquo;s a NuGet package that you add to any VS project, and it will produce the Dnn module installation zip for you when you build the project. It then also extends the package manager console window in VS with an additional command you can run, that will deploy the module project to a local DNN website. So this is the workflow I currently use for module debugging:</p>

<ol>
<li>Make a change to the code</li>
<li>Hit “up” arrow and then hit “enter” in package manager console (this runs the previous command which is the DnnPackager one I spoke of, that builds and deploys my module project to my local dnn website)</li>
<li>Refresh my browser page, and attach Visual Studio (ctrl + alt + p) to the w3w process.</li>
</ol>


<p>This is a bit more streamlined! This makes approach #2 workable in my opinion.</p>

<h3>Room for Improvements!</h3>

<ol>
<li>What if I don’t have a DNN website already installed - for example I am new to Dnn development and just want to get up and running as quickly as possible.</li>
<li>What if I am curious to know if my module runs in DNN 6.5.1 and I only have DNN7 installed?</li>
<li>What if this is the first time I am testing this particular module - I have to make sure I go to DotNetNuke website, Create a page and add my module to that page right?</li>
</ol>


<p>These things are all tedious. Most developers (new to DNN) expect to be able to click Debug and immediately be debugging their code - they don’t expect to have to jump through these additional hurdles / barriers.</p>

<p>This is why DotNetNuke development can be a bit of a culture shock for many developers.</p>

<h3>Next Feature!</h3>

<p>So the next feature I am thinking of adding to DnnPackager is one that addresses those concerns mentioned above. I’d be really greatful if anyone with such a curiousity wouldn&rsquo;t mind reading it and offering their feedback on this proposed awesome feature <a href="https://github.com/dazinator/DnnPackager/issues/14">https://github.com/dazinator/DnnPackager/issues/14</a> - just so I can get a feel for whether there is much demand for such a capability.</p>

<h3>Feedback?</h3>

<p>Do you disagree?
Would this new feature <a href="https://github.com/dazinator/DnnPackager/issues/14">https://github.com/dazinator/DnnPackager/issues/14</a> help you?</p>

<p>Darrell Tunnell
<a href="http://darrelltunnell.net">http://darrelltunnell.net</a></p>
]]></content>
  </entry>
  
</feed>
